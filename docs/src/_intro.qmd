---
format: 
  commonmark:
    variant: -raw_html+tex_math_dollars
    wrap: none
execute: 
  freeze: auto
  eval: true
  echo: true
  output: true
julia: julia-1.10
bibliography: ../../references.bib
---

# EcoVeg

```{julia activate_environment}
#| include: false
using Pkg; Pkg.activate("docs")
```

```{julia}
using EcoVeg
using InvertedIndices
using Clustering
```

Tools for vegetation science.

## Background

`EcoVeg.jl` contains tools for vegetation science using the Julia programming language [@bezanson2017].

Solves two language problem [@roesch2023]

Aims to collate functionality found in JUICE, vegan, MAVIS into a single location with a user-friendly API and transparent methodologies. With the aim of assisting in the creation of reproducible analysis [@sperandii2024].

Nomenclature follows @theurillat2021.


## Installation 

To install the latest stable release of `EcoVeg`:

```{.julia}
using Pkg
Pkg.add("EcoVeg")
```

To install the development version of `EcoVeg`:

```{.julia}
using Pkg
Pkg.add(url="https://github.com/ZekeMarshall/EcoVeg.jl", rev = "develop")
```

## Usage Example 

To demonstrate...

First we begin with generating two example plot by species `NamedArrays.NamedMatrix` object using the function `EcoVeg.generate_test_array` as test data.

```{julia example_data}
x = generate_test_array(rown = 30, coln = 20, meancoloccs = 10, rowprefix = "SiteA-", colprefix = "Species")
```

### Classification

Let's identify some clusters.

```{julia fuzzy_c_clusters}
r = Clustering.fuzzy_cmeans(transpose(x), 3, 2)

cluster_weights = r.weights
memberships_vec = vec(Tuple.(findmax(cluster_weights, dims = 2)[2]))
memberships_mat = hcat(first.(memberships_vec), last.(memberships_vec))

memberships = Dict

for i in unique(memberships_mat[:,2])

    rowids = memberships_mat[memberships_mat[:,2] .== i, :][:,1]
    memberships_i = Dict(i => rowids)
    memberships = merge(memberships, memberships_i)
    
end

memberships
```

### Creation of Syntopic Tables

Once the plots have been grouped into clusters, we can proceed to summarise their composition via the creation of `SyntopicTable` objects.

```{julia syntopic_table_x}
syn_1 = EcoVeg.compose_syntopic_table_object("Syn1", x[getindex(memberships, 1),:])
syn_2 = EcoVeg.compose_syntopic_table_object("Syn2", x[getindex(memberships, 2),:])
print_summary_syntopic_table(syn_2, "normal", "cover_proportion")
```

### Identification of High-Fidelity Species

### Generation of Pseudo-Releves

### Assignment of Releves to Vegetation Classes

Let's generate a second example matrix, consisting of sample 5 releves, against which we want to calculate the similarity.

```{julia example_data}
y = generate_test_array(rown = 5, coln = 30, meancoloccs = 5, rowprefix = "SiteB-", colprefix = "Species")
```

Three methods will be demonstrated.

### Jaccard Similarity

### Czekanowski Index

First, let's compose a syntopic table object from the "y" sample data and extract the syntopic tables in matrix format.

```{julia syntopic_table_y}
syn_y = EcoVeg.compose_syntopic_table_object("Sample", y)
syn_y_mat = extract_syntopic_matrix(syn_y)
syn_1_mat = extract_syntopic_matrix(syn_1)
syn_2_mat = extract_syntopic_matrix(syn_2)
```

Now we have three matrices, containg the relative frequencies of each species present in the sample releves which constitute the phytocoenosis'.
However, each of the phytocoenosis is composed of a different set of species, in Julia we need a helper function to merge these matrices and ensure each matric contains each species across all the matrices.

```{julia merge_arrays}
merged_syn_mats = EcoVeg.merge_namedarrays([syn_y_mat, syn_1_mat, syn_2_mat])
```

```{julia czekanowski_index}
EcoVeg.czekanowski_index(merged_syn_mats[[:"Sample"],:], merged_syn_mats[Not(:"Sample"), :])
```

### Multivariate Analysis

### Ecological Trajectory Analysis

### Example Workflow

```{julia drwatson}
#| include: false

```

## External Resources 

## Implemented Methodologies

## Contribute 

## Acknowledgements

## References 