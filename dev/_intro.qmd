---
format: 
  commonmark:
    variant: -raw_html+tex_math_dollars
    wrap: none
execute: 
  freeze: auto
  eval: true
  echo: true
  output: true
julia: julia-1.10
bibliography: ../../references.bib
---

# VegSci

```{julia activate_environment}
#| include: false
using Pkg; Pkg.activate("docs")
```

```{julia load_packages}
#| include: false
using VegSci
using InvertedIndices
using Clustering
```

Tools for vegetation science.

## Background

`VegSci.jl` is a package containing tools for vegetation science using Julia [@bezanson2017], a growing scientific programming language which solves the 'two language problem' [@roesch2023], offering C and FORTRAN-like performance alongside the readability and user-friendliness of higher level languages such as Python.
`VegSci.jl` aims to collate selected functionality found in popular vegetation science software programs/packages such as JUICE, vegan, ade4, vegclust, vegsoup, and ecotraj into a single location with a user-friendly API and transparent methodologies. 
`VegSci.jl` is being developed with the aim of assisting in the creation of high-performance, reproducible analytical pipelines in vegetation research [@sperandii2024], developed primarily with the application to the vegetation of Great Britain in mind, but fully generalisable.
Nomenclature follows @theurillat2021.


## Installation 

To install the latest stable release of `VegSci`:

```{.julia}
using Pkg
Pkg.add("VegSci")
```

To install the development version of `VegSci`:

```{.julia}
using Pkg
Pkg.add(url="https://github.com/ZekeMarshall/VegSci.jl", rev = "develop")
```

## Usage Example 

To demonstrate...

First we begin with generating two example plot by species `NamedArrays.NamedMatrix` object using the function `VegSci.generate_test_array` as test data.

```{julia example_data}
x = VegSci.generate_test_array(rown = 30, coln = 20, meancoloccs = 10, rowprefix = "SiteA-", colprefix = "Species")
```

### Classification

Let's identify some clusters.

```{julia fuzzy_c_clusters}
r = Clustering.fuzzy_cmeans(transpose(x), 3, 2)

cluster_weights = r.weights
memberships_vec = vec(Tuple.(findmax(cluster_weights, dims = 2)[2]))
memberships_mat = hcat(first.(memberships_vec), last.(memberships_vec))

memberships = Dict

for i in unique(memberships_mat[:,2])

    rowids = memberships_mat[memberships_mat[:,2] .== i, :][:,1]
    memberships_i = Dict(i => rowids)
    memberships = merge(memberships, memberships_i)
    
end

memberships
```

### Creation of Syntopic Tables

Once the plots have been grouped into clusters, we can proceed to summarise their composition via the creation of `SyntopicTable` objects.

```{julia syntopic_table_x}
syn_1 = VegSci.compose_syntopic_table_object("Syn1", x[getindex(memberships, 1),:])
syn_2 = VegSci.compose_syntopic_table_object("Syn2", x[getindex(memberships, 2),:])
VegSci.print_summary_syntopic_table(syn_2, "normal", "cover_proportion")
```

### Identification of High-Fidelity Species

### Generation of Pseudo-Releves

### Assignment of Releves to Vegetation Classes

Let's generate a second example matrix, consisting of sample 5 releves, against which we want to calculate the similarity.

```{julia example_data}
y = VegSci.generate_test_array(rown = 5, coln = 30, meancoloccs = 5, rowprefix = "SiteB-", colprefix = "Species")
```

Three methods will be demonstrated.

### Jaccard Similarity

### Steinhaus coefficient

First, let's compose a syntopic table object from the "y" sample data and extract the syntopic tables in matrix format.

```{julia syntopic_table_y}
syn_y = VegSci.compose_syntopic_table_object("Sample", y)
syn_y_mat = VegSci.extract_syntopic_matrix(syn_y)
syn_1_mat = VegSci.extract_syntopic_matrix(syn_1)
syn_2_mat = VegSci.extract_syntopic_matrix(syn_2)
```

Now we have three matrices, containg the relative frequencies of each species present in the sample releves which constitute each syntaxon.
However, each of the syntaxa are composed of a different set of species, in Julia we need a helper function to merge these matrices and ensure each matrix contains each species across all the matrices. This function is broadly equivalent to the R function `base::merge`.

```{julia merge_arrays}
merged_syn_mats = VegSci.merge_namedarrays([syn_y_mat, syn_1_mat, syn_2_mat])
```

```{julia steinhaus_coefficient}
VegSci.steinhaus_coefficient(merged_syn_mats[[:"Sample"],:], merged_syn_mats[Not(:"Sample"), :])
```

### Multivariate Analysis

### Ecological Trajectory Analysis

### Example Workflow

```{julia drwatson}
#| include: false

```

## External Resources 

## Implemented Methodologies

## Contribute 

## Acknowledgements

## References 